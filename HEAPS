public class HeapsUtils {

    public void MaxHeapify(int []A, int i, int heapsize){
        int l = left(i);
        int r = right (i);
        int largest = i;

        if(l < heapsize && A[l] > A[i]){
            largest = l;
        }

        if(r < heapsize && A[r] > A[largest]){
            largest = r;
        }

        if(largest != i){
            //INTERCAMBIO A[i] CON A[largest]
            int temp = A[i];
            A[i] = A[largest];
            A[largest] = temp;
            MaxHeapify(A, largest, heapsize);

        }
    }

    public void buildMax(int []A){
        int heapsize = A.length;

        //Desde el ultimo nodo padre hasta la raiz
        for(int i = (heapsize/2) - 1;i >= 0;i--){
            MaxHeapify(A,i,heapsize);
        }
    }

    public int HeapMax(int []A){
        return A[0];
    }

    public void increaseKey(int []A, int i, int key){
        if(key < A[i]){
            System.out.println("la nueva clave es más pequeña que la actual");
        }

        A[i] = key;
        while(i > 0 && A[key] < A[i]){
            //Cambiar la clave anterior por una de mayor tamaño

        }
    }

    public void cambio(int []A, int heapsize, int key){

    }

    public int ExtractMax(int []A){
        int heapsize = A.length;

        if(heapsize < 1){
            System.out.println("Heap Vacio");
            return 0;
        }

        int Max = A[0]; // raiz
        A[0] = A[heapsize - 1];
        heapsize--;
        MaxHeapify(A, 0, heapsize);

        return Max;
    }

    public void insert(int x){

    }

    public void Mostrar(int []A, int heapsize){
        for(int i = 0; i < heapsize;i++){
            System.out.print(A[i] + " ");
        }
    }

    private static int left(int i){
        return 2 * i + 1;
    }

    private static int right(int i){
        return 2 * i + 2;
    }
}
